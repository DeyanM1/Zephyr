{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Zephyr is a variable-based programming language designed for simplicity and efficiency. In Zephyr, all variables are lowercase, and the syntax is minimalistic, allowing you to define and manipulate variables, perform calculations, and structure your programs using loops, functions, and conditional logic.</p>"},{"location":"#vision-and-purpose","title":"Vision and Purpose","text":"<p>Welcome to the Zephyr project! My goal is to create the world's first variable-based programming language, designed to provide an innovative and intuitive approach to understanding the inner workings of programming languages. This language is tailored for intermediate to professional developers who want to deepen their knowledge of how programming languages parse, compile, and execute code.</p>"},{"location":"#why-this-language","title":"Why This Language?","text":"<p>Programming languages often abstract away the low-level details of how they handle code, making it challenging for developers to fully grasp the mechanics of compilation and execution. With Zephyr, I aim to bridge this gap. By focusing on variables as a central concept, this language provides developers with a clear, hands-on perspective on how code is processed under the hood.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Variable-Centric Design: A unique syntax and structure that revolve around variables as the primary building blocks of code.</li> <li>Educational Focus: Ideal for developers who want to learn or teach the concepts of parsing and compiling in a practical way.</li> <li>Comprehensive Documentation: The language comes with detailed, beginner-friendly, and well-organized documentation to help users understand its syntax, features, and concepts thoroughly.</li> </ul>"},{"location":"#who-is-it-for","title":"Who Is It For?","text":"<p>This language is intended for:</p> <ul> <li>Intermediate developers who want to expand their understanding of programming language design.</li> <li>Experienced professionals exploring innovative ways to teach or experiment with compilation processes.</li> <li>Curious learners interested in diving deeper into how programming languages work behind the scenes.</li> </ul>"},{"location":"#start-writing-programs-here","title":"Start writing programs here","text":""},{"location":"#notes","title":"Notes","text":"<p>https://patorjk.com/software/taag/#p=display&amp;f=ANSI%20Shadow&amp;t=Zephyr%0A https://convertio.co/txt-png/</p>"},{"location":"Overview/","title":"Overview","text":""},{"location":"Overview/#basic-structure","title":"Basic Structure","text":"<p>Zephyr commands follow a strict structure:</p> <pre><code>&lt;VariableName&gt; &lt;base&gt; &lt;function&gt;:&lt;Argument1&gt;|&lt;Argument2&gt;|...;\n&lt;---------------------------command-------------------------&gt;\n</code></pre> <ul> <li>VariableName: User-defined name of the variable.</li> <li> <p>base: Determines the operation type:</p> </li> <li> <p><code>#</code> \u2013 Declare a variable or change its type.</p> </li> <li><code>?</code> \u2013 Operate on an existing variable (e.g., modify or retrieve values).</li> <li>function: The specific operation to execute.</li> <li>arguments: Additional information passed to the function.</li> <li>command: Complete statement executed by Zephyr.</li> </ul>"},{"location":"Overview/#file-extensions","title":"File Extensions","text":"<ul> <li>.zph \u2013 Zephyr script file.</li> <li>.zsrc \u2013 Zephyr source file for debugging.</li> <li>.zpkg \u2013 Dumped variables file.</li> </ul>"},{"location":"Overview/#running-a-script","title":"Running a Script","text":"<ol> <li>Locate your <code>.zph</code> script.</li> <li>Run <code>cli.py</code> located in the <code>src</code> directory.</li> <li>Pass the path to your <code>.zph</code> file as a parameter.</li> </ol> <p>Command:</p> <pre><code>python src/cli.py &lt;path_to_file.zph&gt;\n</code></pre> <p>--</p>"},{"location":"Overview/#comments","title":"Comments","text":"<p>Text after <code>~</code> on a line is ignored by the compiler.</p> <p>Usage:</p> <pre><code>a # PT:'HelloWorld'; ~ This is a comment\n~ This entire line is a comment\n</code></pre>"},{"location":"Overview/#starting-info","title":"Starting Info","text":"<ul> <li><code>*</code>: Represents a value that can be a variable name or input (must be enclosed in <code>' '</code> where specified).</li> <li><code>-</code>: Represents an optional parameter in the command.</li> </ul>"},{"location":"Overview/#declaring-variables","title":"Declaring Variables","text":"<p>Declare a variable by specifying its name, type, and initial value:</p> <pre><code>&lt;VariableName&gt; # &lt;Type&gt;:&lt;Value&gt;|&lt;Param1&gt;|&lt;Param2&gt;|...;\n</code></pre> <ul> <li>VariableName \u2013 Name of the variable.</li> <li>Type \u2013 Data type (<code>PT</code>, <code>INT</code>, <code>FLOAT</code>).</li> <li>Value \u2013 Initial value of the variable.</li> <li>Param \u2013 Optional parameters separated by <code>|</code>.</li> </ul> <p>Examples:</p> <pre><code>counter # INT:10;          ~ Declare integer\nmessage # PT:\"Hello World\"|~1;  ~ Declare constant text\n</code></pre>"},{"location":"Overview/#changing-type","title":"Changing Type","text":"<p>Use <code># CT:</code> to change a variable\u2019s type. This resets its value.</p> <p>Supported types indicate which types the variable can be changed into.</p> <pre><code>&lt;VariableName&gt; # CT:&lt;Type&gt;;\n</code></pre> <p>Example:</p> <pre><code>counter # INT:5;\ncounter # CT:PT; ~ counter is now a Printable Text\n</code></pre>"},{"location":"Libraries/01-GPIO/","title":"GPIO","text":"<p>Value represents the status of the last read pin.</p> <p>GPIO objects allow programs to interface with hardware pins for input and output. They support pin setup, reading, writing, and cleanup.</p> <ul> <li>Import GPIO library:</li> </ul> <pre><code>__ ? LIB:./lib/GPIO.py;\n</code></pre> <ul> <li>Define GPIO setup:</li> </ul> <pre><code>gpio # GPIO:&lt;*PinoutType&gt;;   ~ PinoutType: BCM or Board\n</code></pre> <ul> <li>Configure pin:</li> </ul> <pre><code>gpio ? SETUP:&lt;*PinNum&gt;|&lt;*PinType&gt;;   ~ PinType: IN or OUT\n</code></pre> <ul> <li>Set pin value:</li> </ul> <pre><code>gpio ? SET:&lt;*PinNum&gt;|&lt;*PinValue&gt;;   ~ PinValue: 1 (HIGH) or 0 (LOW)\n</code></pre> <ul> <li>Read pin value:</li> </ul> <pre><code>gpio ? READ:&lt;*PinNum&gt;;   ~ Requires pin set to IN\n</code></pre> <ul> <li>Clean all pins:</li> </ul> <pre><code>gpio ? CLEAN:;\n</code></pre>"},{"location":"Types/01-simpleVariable/","title":"Simple Variable","text":"<p>Supported types: <code>INT</code>, <code>PT</code>, <code>FLOAT</code></p> <p>Simple Variables store single pieces of data that can be changed, incremented, decremented, printed, or replaced with user input. They are the basic building blocks for storing values in Zephyr.</p> <ul> <li>Define:</li> </ul> <pre><code>var # &lt;Vartype&gt;:&lt;*Value&gt;;\n</code></pre> <ul> <li>Update value:</li> </ul> <pre><code>var ? w:&lt;*NewValue&gt;;\n</code></pre> <ul> <li>Increment (INT/FLOAT):</li> </ul> <pre><code>var ? w:++|&lt;*incrementBy&gt;;   ~ Defaults to 1 if not set\n</code></pre> <ul> <li>Decrement (INT/FLOAT):</li> </ul> <pre><code>var ? w:-|&lt;*decrementBy&gt;;    ~ Defaults to 1 if not set\n</code></pre> <ul> <li>Print PT value:</li> </ul> <pre><code>var ? push:;\n</code></pre> <ul> <li>Take input:</li> </ul> <pre><code>var ? INPUT:&lt;*Message&gt;;      ~ Overrides previous value\n</code></pre>"},{"location":"Types/02-conditionalObject/","title":"Conditional Object","text":"<p>Supported types: <code>INT</code>, <code>PT</code>, <code>FLOAT</code></p> <p>Conditional Objects evaluate a condition and store its result. They are used to drive decision-making in IF statements or loops.</p> <ul> <li>Define:</li> </ul> <pre><code>co # CO:&lt;*ConditionScript&gt;;\n</code></pre> <ul> <li>Update:</li> </ul> <pre><code>co ? w:&lt;*ConditionScript&gt;;\n</code></pre> <p>Condition format example:</p> <pre><code>('a' &gt; 'b')\n</code></pre>"},{"location":"Types/03-IF-Statement/","title":"IF-Statement","text":"<p>Once defined, the variable name/state cannot be changed.</p> <p>IF statements execute a block of code only if a related Conditional Object evaluates to true. They optionally allow an ELSE block for false conditions.</p> <ul> <li>Define:</li> </ul> <pre><code>if # IF:&lt;*ConditionalObjectName&gt;;\n</code></pre> <ul> <li>Change condition:</li> </ul> <pre><code>if ? w:&lt;*ConditionalObjectName&gt;;\n</code></pre> <ul> <li>Start block:</li> </ul> <pre><code>if ? START:&lt;*commandsInIF&gt;;\n</code></pre> <ul> <li>Else block:</li> </ul> <pre><code>if ? ELSE:&lt;*commandsInELSE&gt;;\n</code></pre> <ul> <li>End IF block:</li> </ul> <pre><code>if ? END:;\n</code></pre>"},{"location":"Types/04-LOOP/","title":"LOOP","text":"<p>Supported types: <code>INT</code>, <code>PT</code>, <code>FLOAT</code> Value represents the number of iterations.</p> <p>LOOP objects repeatedly execute a block of code while a Conditional Object evaluates to true. Their value updates to reflect the number of completed iterations.</p> <ul> <li>Define:</li> </ul> <pre><code>loop # LOOP:&lt;*ConditionalObjectName&gt;;\n</code></pre> <ul> <li>Change condition:</li> </ul> <pre><code>loop ? w:&lt;*ConditionalObjectName&gt;;\n</code></pre> <ul> <li>Start loop block:</li> </ul> <pre><code>loop ? START:&lt;*commandsInLOOP&gt;;\n</code></pre> <ul> <li>End loop block:</li> </ul> <pre><code>loop ? END:;\n</code></pre>"},{"location":"Types/05-MathObjects/","title":"Math Object","text":"<p>Supported types: <code>INT</code>, <code>PT</code>, <code>FLOAT</code> Value is calculated whenever the script is set or changed.</p> <p>Math Objects evaluate an equation or script and store the result. They simplify calculations and can be reused in functions or other objects.</p> <ul> <li>Define:</li> </ul> <pre><code>mo # MO:&lt;*EquationScript&gt;;\n</code></pre> <ul> <li>Update:</li> </ul> <pre><code>mo ? w:&lt;*EquationScript&gt;;\n</code></pre>"},{"location":"Types/06-Functions/","title":"Function","text":"<p>Supported types: <code>INT</code>, <code>PT</code>, <code>FLOAT</code> Value is calculated only when called.</p> <p>Functions wrap a Math Object to allow reusable calculations. They only compute a result when explicitly called, enabling modular programming.</p> <ul> <li>Define:</li> </ul> <pre><code>func # FUNC:&lt;ResultType&gt;|&lt;*disableVariableChange&gt;|&lt;*MathObjectName&gt;;\n</code></pre> <ul> <li>Change Math Object:</li> </ul> <pre><code>func ? w:&lt;*MathObjectName&gt;;\n</code></pre> <ul> <li>Call function:</li> </ul> <pre><code>func ? call:;\n</code></pre>"},{"location":"Types/07-RNG/","title":"Random Number Generator","text":"<p>Supported types: <code>INT</code>, <code>PT</code>, <code>FLOAT</code></p> <p>RNG objects generate a random number within a specified range. They are useful for simulations, random decisions, or game logic.</p> <ul> <li>Define:</li> </ul> <pre><code>rng # RNG:&lt;*RangeMin&gt;|&lt;*RangeMax&gt;|&lt;*NumberType&gt;;\n</code></pre> <ul> <li>Update:</li> </ul> <pre><code>rng ? w:&lt;*RangeMin&gt;|&lt;*RangeMax&gt;|&lt;*NumberType&gt;;\n</code></pre>"},{"location":"Types/08-FileManagement/","title":"File Management","text":"<p>Variable state cannot be changed. Value is the absolute path.</p> <p>File objects manage opening, editing, renaming, and deleting files. They allow Zephyr programs to store and manipulate external data.</p> <ul> <li>Open file:</li> </ul> <pre><code>file # FILE:&lt;*Path&gt;;  ~ Defaults to 'unnamed_file.txt'\n</code></pre> <ul> <li>Change file path:</li> </ul> <pre><code>file ? w:&lt;*Path&gt;;\n</code></pre> <ul> <li>Set file content:</li> </ul> <pre><code>file ? cSET:&lt;*Content&gt;;\n</code></pre> <ul> <li>Clear file content:</li> </ul> <pre><code>file ? cFLUSH:;\n</code></pre> <ul> <li>Rename file:</li> </ul> <pre><code>file ? gRENAME:&lt;*NewName&gt;;\n</code></pre> <ul> <li>Delete file:</li> </ul> <pre><code>file ? gDEL:;\n</code></pre>"},{"location":"Types/09-BuiltIn/","title":"Built-in (<code>__</code>)","text":"<p>Variable state cannot be changed. Always named <code>__</code>.</p> <p>Built-in commands control program flow, timing, persistence, and library imports. They provide core functionality without requiring explicit definition.</p> <ul> <li>Wait:</li> </ul> <pre><code>__ ? wait:&lt;*SecondsToWait&gt;;\n</code></pre> <ul> <li>Jump relative:</li> </ul> <pre><code>__ ? jump:&lt;*RelativePositionInCode&gt;;\n</code></pre> <ul> <li>Jump absolute:</li> </ul> <pre><code>__ ? jumpTo:&lt;*AbsolutePositionInCode&gt;;\n</code></pre> <ul> <li>Export variables:</li> </ul> <pre><code>__ ? export:&lt;*ExportPath&gt;;  ~ Defaults to `.zpkg` matching `.zph` filename\n</code></pre> <ul> <li>Import variables:</li> </ul> <pre><code>__ ? load:&lt;*ImportPath&gt;;\n</code></pre> <ul> <li>Import library:</li> </ul> <pre><code>__ ? LIB:&lt;*LibFilePath&gt;;\n</code></pre>"}]}